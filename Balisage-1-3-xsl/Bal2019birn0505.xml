<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="../Balisage-1-3-rng/balisage-1-3.rng" type="application/xml" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-stylesheet type="text/xsl" href="balisage-proceedings-html.xsl"?>
<article xmlns="http://docbook.org/ns/docbook">
    <title>The integration of XML databases and content management systems in digital
        editions</title>
    <subtitle>Understanding eXist-db through Reese’s Peanut Butter Cups</subtitle>
    <info>
        <abstract>
            <para>We have identified four models for integrating digital edition content into
                eXist-db [<xref linkend="eXist-db"/>], which are in increasing order of dependence
                on eXist-db itself: 1) using Apache [<xref linkend="apache"/>] and PHP [<xref
                    linkend="php"/>] to mediate between the user and eXist-db, so that eXist-db
                provides only XML database services, 2) the pure XQuery framework for building an
                    [<xref linkend="webapp"/>], 3) the eXist-db HTML templating framework [<xref
                    linkend="templating"/>], and 4) TEI Publisher [<xref linkend="teiPublisher"/>].
                Our presentation will examine and compare these ways of conceptualizing and
                implementing the infrastructure for a digital edition. Each of them has advantages
                and disadvantages, primarily from the perspective of sustainability. These
                considerations apply to edition frameworks generally, and are therefore not specific
                to eXist-db, but eXist-db is discussed here because of the number of editions that
                use it and the variety of models employed.</para>
        </abstract>
        <author>
            <personname>
                <firstname>David</firstname>
                <othername>J.</othername>
                <surname>Birnbaum</surname>
            </personname>
            <personblurb>
                <para>David J. Birnbaum is Professor and Chair of the Department of Slavic Languages
                    and Literatures at the University of Pittsburgh. He has been involved in the
                    study of electronic text technology since the mid-1980s, has delivered
                    presentations at a variety of electronic text technology conferences, and has
                    served on the board of the Association for Computers and the Humanities, the
                    editorial board of <emphasis role="ital">Markup languages: theory and
                        practice</emphasis>, and the Text Encoding Initiative Technical Council.
                    Much of his electronic text work intersects with his research in medieval Slavic
                    manuscript studies, but he also often writes about issues in the philosophy of
                    markup.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Professor and Chair</jobtitle>
                <orgname>Department of Slavic Languages and Literatures, University of Pittsburgh
                    (US)</orgname>
            </affiliation>
            <email>djbpitt@gmail.com</email>
            <link>http://www.obdurodon.org</link>
        </author>
        <author>
            <personname>
                <firstname>Hugh</firstname>
                <surname>Cayless</surname>
            </personname>
            <personblurb>
                <para>Hugh Cayless is Senior Digital Humanities Developer at Duke University, where
                    he provides architecture, design, and programming support for the Duke
                    Collaboratory for Classics Computing (DC3). He has served as an elected member
                    of the TEI Technical Council since 2012 (as its Chair from 2015–2017), and he is
                    a founding member of the EpiDoc Collaborative. Hugh earned a PhD in Classics and
                    an MSIS, both from UNC Chapel Hill. His research interests focus on digital
                    critical editions and Linked Open Data.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Senior Digital Humanities Developer</jobtitle>
                <orgname>Duke University (US)</orgname>
            </affiliation>
            <email>philomousos@gmail.com </email>
            <link>http://philomousos.com/</link>
        </author>
        <author>
            <personname>
                <firstname>Emmanuelle</firstname>
                <surname>Morlock</surname>
            </personname>
            <personblurb>
                <para>Emmanuelle Morlock has been working as an engineer in Digital Humanities at
                    the French National Center for Scientific Research (CNRS) since 2008. Educated
                    in French literature and Library and Information Science, she has specialized in
                    the application of the encoding standard TEI EpiDoc, a version of the guidelines
                    of the Text Encoding Initiative (TEI) that is dedicated to ancient documents.
                    Emmanuelle manages several digitial scholarly editions projects within the
                    History and Sources of the Ancient Worlds (HiSoMA) Research Center, and she is
                    also involved in the French-speaking digital humanities association Humanistica
                    as a member of the steering commitee and co-director of the digital open access
                    journal <emphasis role="ital">Humanités numériques</emphasis>.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Digital Humanities Research Officer</jobtitle>
                <orgname>French National Center for Scientific Research (CNRS)</orgname>
            </affiliation>
            <affiliation>
                <jobtitle>Full member</jobtitle>
                <orgname>History and Sources of the Ancient Worlds (HiSoMA) Research Center, Lyon
                    (France)</orgname>
            </affiliation>
        </author>
        <author>
            <personname>
                <firstname>Leif-Jöran</firstname>
                <surname>Olsson</surname>
            </personname>
            <personblurb>
                <para>Leif-Jöran Olsson has been employed since 2005 as a systems developer at
                    Språkbanken, the Swedish Language bank, University of Gothenburg, where he
                    develops research infrastructure for language technology, both nationally and
                    within CLARIN ERIC. His project management experience involves both long-term
                    partner projects (e.g., the Swedish Literary Bank, the Selma Lagerlöf Archive,
                    the Swedish Drama web) and short-term domain-specific toolboxes (including
                    training and use case analysis). He has extensive experience with teaching in
                    language technology and programming. Leif-Jöran obtained his MA in Language
                    Technology from Uppsala University in 2004, and he is one of the core developers
                    of the open-source eXist-db native XML database.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Systems Developer</jobtitle>
                <orgname>Språkbanken, Department of Swedish, University of Gothenburg
                    (Sweden)</orgname>
            </affiliation>
            <email>leif-joran.olsson@svenska.gu.se</email>
            <link>https://spraakbanken.gu.se/personal/ljo</link>
        </author>
        <author>
            <personname>
                <firstname>Joseph</firstname>
                <surname>Wicentowski</surname>
            </personname>
            <personblurb>
                <para>Joseph Wicentowski is a historian who specializes in the use of open standards
                    to improve the accessibility and utility of scholarly editions. Since completing
                    his Ph.D. in History at Harvard University in 2007, he has spearheaded a project
                    to convert a major diplomatic documentary edition to TEI, leveraging the XML
                    family of technologies to enable editors, researchers, and the public to access
                    texts online in multiple open formats. Wicentowski has led workshops on the
                    XQuery language and the eXist-db open source native XML database at TEI@Oxford
                    Summer School in 2010–11 and Digital Humanities 2017, serves as a community
                    liaison for the eXist-db community, and is co-author of a forthcoming book on
                    XQuery for digital humanists in the Coding for Humanists series from Texas
                    A&amp;M University Press.</para>
            </personblurb>
            <affiliation>
                <jobtitle>Digital History Advisor</jobtitle>
                <orgname>Office of the Historian, US Department of State</orgname>
            </affiliation>
            <email>joewiz@gmail.com</email>
            <link>https://github.com/joewiz</link>
        </author>
    </info>
    <section>
        <title>Introduction</title>
        <para>In the 1980s Reese’s Peanut Butter Cups, long owned by the Hershey Corporation and one
            of the best selling and most popular candy products in the US (<xref linkend="upton"/>),
            deployed an advertising campaign that portrayed the idea of eating chocolate and peanut
            butter together as a serendipitous pleasure. In one television advertisement (<xref
                linkend="reeses"/>), two persons accidentally walk into each other on the street, he
            eating a chocolate bar and she (perhaps surprisingly) eating peanut butter out of a jar
            with her finger. They collide, the chocolate bar winds up embedded in the peanut butter,
            and they protest, in unison: <quote>You got your chocolate in my peanut butter</quote>
            and <quote>You got peanut butter on my chocolate!</quote> They both then,
            simultaneously, realize that they like the taste of the combination, and proclaim, still
            in unison, <quote>Delicious!</quote>, as an older man (apparently a grocer; he wears an
            apron) suddenly materializes between them, standing uncomfortably close and silently
            ogling the packaged Reese’s Peanut Butter Cups that he holds up (for the camera; it is
            behind the field of view of the two principals).</para>
        <figure xml:id="reeses_image" xreflabel="Reese’s Peanut Butter Cups (commercial; product)">
            <mediaobject>
                <imageobject>
                    <imagedata format="jpg" fileref="reeses.jpg" width="49%"/>
                </imageobject>
                <imageobject>
                    <imagedata fileref="reeses-wrappers.jpg" width="49%"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Meanwhile, in a galaxy far, far away, the eXist-db native XML database was born in
            2001. Created by Wolfgang Meier, who at the time was a researcher in the field of
            sociology, to support his projects which required efficient processing of XML documents,
            eXist-db was released as a free, open source project that has enjoyed a broad following
            in the world of XML and NoSQL databases, and is particularly strong in publishing and,
            for the purposes of this paper, digital edition projects in the humanities. Since its
            inception, eXist-db has provided the services one expects from any database management
            system (DBMS): it stores records (XML documents), builds persistent indexes, supports
            retrieval with a query language (first DOM and XPath, and later XQuery), and provides
            the housekeeping functionality (e.g., user authentication) those processes require.
            eXist-db is commonly hosted inside an HTTP server and servlet container (it ships with
                <xref linkend="Jetty"/>, but other hosts are also supported), which mediates between
            the user and the eXist-db functionality, as is illustrated in this image from <xref
                linkend="exist-book"/>:</para>
        <figure xml:id="exist-book-jetty"
            xreflabel="eXist-db web application platform architecture (Siegel and Retter 2014: 72)">
            <mediaobject>
                <imageobject>
                    <imagedata format="jpg" fileref="jetty.jpg" width="40%"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Since its early years users have been able to interact with eXist-db by communicating
            directly with the Jetty server, and over time eXist-db has increasingly come to support
            features that are more commonly associated with a Content Management System (CMS) than
            with a database, such as themes, templates, and page management (not just data resource
            management). We might consider the eXist-db core functionality, the DBMS services at the
            innermost layer of an eXist-db installation, as analogous to the thick peanut butter
            center of a Reese’s Peanut Butter Cup, and the Jetty servlet container, which provides
            eXist-db's REST interface, as the thin outer layer of chocolate. But the analogy does
            not depend only on the fact that the eXist-db DBMS services are wrapped, as it were,
            inside Jetty’s CMS ones. Peanut butter and chocolate have a long history as
            independently popular foodstuffs, and neither depends in any necessary, obvious, or even
            intuitive way on the other, yet their combination in a single product has proven
            impressively popular with consumers. Similarly, there is nothing about a DBMS that
            requires or expects CMS services, and vice versa, yet the growing integration of the two
            types of functionality within eXist-db confirms that they can be combined to create a
            resource for developing and deploying digital editions.</para>
        <para>While digital editions based on eXist-db have been released using a variety of
            architectures, the release of TEI Publisher 4.0 in December 2018 [<xref
                linkend="teiPublisher4.0"/>] caused educators and creators of digital editions, such
            as the authors of this paper, to review the existing architectures against this new one.
            An implementation of the TEI Processing Model that leverages Web Components for its
            default user interface [<xref linkend="webComponents"/>], TEI Publisher can be said to
            turn eXist-db into a hosting platform for digital editions that both goes very far
            beyond traditional DBMS services and provides functionality that would normally be
            expected from a CMS. The TEI Publisher documentation says as much explicitly (see
            especially the paragraph below the numbered list):<blockquote>
                <para>Despite its elegant simplicity, various projects we realized in the past prove
                    that the TEI Processing Model is: <blockquote>
                        <para>1. powerful enough to cover complex transformation needs</para>
                        <para>2. a truly universal tool for any kind of digital edition</para>
                        <para>3. efficient and as fast (or faster) as handwritten
                            transformations</para>
                        <para>4. suitable for any XML, not just TEI (this documentation is written
                            in docbook!)</para>
                    </blockquote>However, online editions require more than just a text
                    transformation: the text needs to be embedded into an application context,
                    adding navigation, pagination, search, facsimile display and so on. The larger
                    part of TEI Publisher deals with those aspects, providing all the necessary
                    building blocks for an online edition. [<xref linkend="teiPublisherQuick"
                    />]</para>
            </blockquote></para>
        <para>After a digression about web application architecture, which serves as a reference
            point for comparison and discussion, in the following sections we describe four models
            for integrating digital edition content into eXist-db. These are, in increasing order of
            eXist-db dependence: <orderedlist>
                <listitem>
                    <para>using Apache [<xref linkend="apache"/>] and PHP [<xref linkend="php"/>] to
                        mediate between the user and eXist-db, so that eXist-db provides only DBMS
                        services;</para>
                </listitem>
                <listitem>
                    <para>the eXist-db app framework without HTML templating [<xref linkend="webapp"
                        />];</para>
                </listitem>
                <listitem>
                    <para>the eXist-db app framework using HTML templating [<xref
                            linkend="templating"/>]; and</para>
                </listitem>
                <listitem>
                    <para>TEI Publisher [<xref linkend="teiPublisher"/>].</para>
                </listitem>
            </orderedlist>Each of these ways of conceptualizing and implementing the infrastructure
            for a digital edition has advantages and disadvantages, primarily from the perspective
            of sustainability. Those concerns are applicable to digital edition frameworks
            generally, and are therefore not specific to eXist-db.</para>
    </section>
    <section>
        <title>Web application architecture </title>
        <para>Digtal editions have some important differences from typical web applications. A
            typical web application architecture has a "front end" or user-facing interface, a
            middle tier which handles interactions between the user and the application's data, and
            a "back end"—a data store of some kind. In most web applications, the front end is HTML,
            CSS, and Javascript, the middle tier is dealt with by some piece of software, often
            developed using a framework with takes care of common tasks. In a digital edition, the
            content, the text of the edition(s), is the primary feature of the application's data
            model. Unless the edition is in a development phase, its content tends to be relatively
            static. Fine details of the edition's structure are apt to matter a great deal., but
            there may be little of no notion of a "user" in the application's data model. Even if it
            is paywalled, access may well be controlled at another level. Its data is
            semi-structured and may have to be made available in a variety of ways. Business logic
            and workflows tend to be applied on the creation and editing side of things, and may
            happen entirely outside the application that publishes the data. </para>
        <para>A digital edition based on the Text Encoding Initiative's guidelines has some
            decisions to make about its back-end and front-end architecture. How will the
            information be stored? Generally, it is sensible to decide on a single "canonical"
            version of the text, from which everything else will derive. If not, there is a risk
            that different representations of the text may get out of sync with one another. So
            where will the canonical version live? On disk, in a data store, or elsewhere (e.g. in a
            remote repository)? How will it be presented? Transformed to HTML using XSLT, XQuery,
            some other mechanism? When will that conversion occur? Ahead of time or upon request?
            Will the conversion be cached or always live? Bound up with these questions is the
            decision of how to structure the software that mediates between the back-end content and
            the front-end presentation. With eXist as the data store, we will have to choose how
            much of the application logic and source-conversion will be handled by eXist
            itself.</para>
        <para>The decision of where to place the application logic of a digital edition and how to
            structure it will be influenced by many factors, including performance, available
            developer expertise, and software functionality. The latter issue can be acute because
            of the stagnation of XML technology development in some areas. Common application
            frameworks such as Ruby on Rails, Flask (Python), or Django (Python) rely on libxml2 and
            libxslt for XML processing, and so are limited to XSLT 1.0. Java or ASP.Net-based
            systems can make use of the more modern XSLT support available in Saxon. EXist-db
            supports XQuery 3.0, but a decision to use it as a complete solution may mean relying
            upon it for things like user management and other functionality which is easier to
            implement on top of a web framework. In addition, it may be far easier to find
            developers qualified to work with a common web application framework than with
            eXist.</para>
        <para>MVC is an architecture that separates an application into three components: Model,
            View, and Controller.<footnote>
                <para>For a history of MVC see <xref linkend="reenskaug"/>.</para>
            </footnote> The following explanation is based on <xref linkend="mvc"/>: <itemizedlist>
                <listitem>
                    <para><emphasis role="bold">Model:</emphasis> the data and core DBMS
                        functionality.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">View:</emphasis> the user interface (UI), such as
                        web forms that accept user input and the HTML returned to the user in
                        response to queries.</para>
                </listitem>
                <listitem>
                    <para><emphasis role="bold">Controller:</emphasis> The interface between the
                        model and the view. The controller may translate user-supplied values from a
                        web form (part of the view) into a database query (interacting with the
                        model) and return the results (drawn from the model) as an HTML page (part
                        of the view).</para>
                </listitem>
            </itemizedlist>These components and the relationships among them may be represented as
                follows:<figure xml:id="mvc_image"
                xreflabel="Three-tier MVC architecture (https://www.wideskills.com/struts/introduction-to-mvc-architecture)">
                <mediaobject>
                    <imageobject>
                        <imagedata format="png" fileref="three-tier-mvc.png" width="50%"/>
                    </imageobject>
                </mediaobject>
            </figure></para>
        <para>The Model in all of the examples below is the XML data stored inside eXist-db and the
            core eXist-db database functionality that interacts with the data (e.g., the ability to
            interpret XQuery and navigate collections and resources). The View in all of the
            examples is the UI, that is, web pages as presented to the user, both those that elicit
            user input (such as query forms) and those that are returned in response to user input
            (such as formatted results returned from a query). The most variable aspect of the
            examples below is the Controller, that is, the part of the architecture that 1) responds
            to user interaction with the View by interacting with the Model and 2) updates the View
            in response to user activity, often recruiting and manipulating user-specified
            information retrieved from the Model.<footnote>
                <para>Two areas of variation in the description of MVC are:<itemizedlist>
                        <listitem>
                            <para>In some descriptions, although the Controller translates user
                                interaction (in the View) into instructions to the Model, the Model
                                returns directly to the View, without passing through the
                                Controller.</para>
                        </listitem>
                        <listitem>
                            <para>The dividing line between the Controller and the Model is not
                                always clear. Basic XQuery support (that is, support for XQuery
                                syntax and the function library) is part of the Model, but whether a
                                particular XQuery script is part of the Model (perhaps stored inside
                                the database) or the Controller (perhaps constructed with PHP and
                                then passed into the database) is less certain. The boundaries may
                                be even harder to discern when all three parts of the MVC
                                architecture are implemented inside eXist-db.</para>
                        </listitem>
                    </itemizedlist></para>
            </footnote></para>
    </section>
    <section>
        <title>Four ways of building an edition with eXist-db</title>
        <section>
            <title>Web application middleware</title>
            <para>A common architecture for web interfaces that incorporate a DBMS (relational, XML,
                or other) is that user requests are mediated by a standard HTTP server, such as
                Apache running on ports 80 and/or 443, which delegates the job of processing
                requests to some middleware, such as PHP scripts, web frameworks like Ruby on Rails
                or Django, or many other alternatives. Under this approach, the front end is
                generated by the middleware, which queries the database (probably via its REST
                interface) for information to be presented in the view. Views might be created by
                transforming XML to HTML with XSLT, or by including HTML fragments generated
                directly from eXist using XQuery. This architecture is similar to that of the
                fundamental open-source LAMP stack: Linux (OS), Apache (HTTP server), MySQL (DBMS),
                and PHP (middleware language), with the DBMS role replaced by eXist. Obviously, PHP
                is only one option for the middle tier language, and herein it should be understood
                to be replaceable by any language filling a similar niche.<footnote>
                    <para>Some other such languages have already been mentioned above, and include
                        Python, Ruby, and JavaScript.</para>
                </footnote></para>
            <para>The strictest implementation of this type of system in an eXist-db context relies
                on eXist-db only as an XML database, that is, as an alternative to the MySQL
                component of LAMP. For example, a PHP script running inside an Apache server on port
                80, which is the only direct point of access for the end-user, might incorporate
                user-supplied form values into an XQuery script that is then passed into eXist-db
                using the eXist-db REST interface. The results of the query are returned to the PHP
                script, which then shapes them into HTML, associates CSS and JavaScript, and returns
                a response page to the user. Under this stricter model, any CSS and JavaScript
                reside on the Apache server because they are part of the front-end functionality,
                and not of the DBMS services. And the only part of the content of the returned page
                (the modified View) that is connected to eXist-db is information that depends on XML
                stored inside eXist-db. The rest of the HTML returned page is part of the PHP
                script.</para>
            <para>Looser implementations of this approach might offload additional Controller
                functionality onto eXist-db. For example, XML retrieved from inside the database
                might be transformed to HTML markup inside eXist-db (using the XQuery
                    <code>typeswitch()</code> function or XSLT by way of the eXist-db
                    <code>transform:transform()</code> function<footnote>
                    <para>As of Version 4.6.1 (March 2019) eXist-db supports a custom
                            <code>transform:transform()</code> function in a custom namespace, but
                        not the standard XPath 3.1 <code>fn:transform()</code> function in the
                        standard XPath 3.1 namespace.</para>
                </footnote>instead of by the PHP script after the eXist-db query returns. Looser
                implementations might also store the XQuery script inside eXist-db and pass it
                user-supplied parameters, instead of integrating the parameters into the query
                within PHP before passing the entire constructed query into eXist-db. And looser
                implementations might store some front-end components inside eXist-db, such as CSS
                and JavaScript, although these might most properly be regarded as aspects of the
                View, rather than of the Model. What these variations all have in common, though, is
                that PHP provides all or most or, at least, some of the Controller functionality of
                the MVC architecture.</para>
            <para>One advantage of using eXist-db only as a DBMS, and limiting its role as
                Controller, is reducing dependency on custom features of eXist-db. To the extent
                that this separation of concerns allows the use of standard XQuery, with no
                non-standard, implementation-specific features, users may replace eXist-db with an
                alternative XML DBMS, such as BaseX [<xref linkend="basex"/>] or Marklogic [<xref
                    linkend="marklogic"/>], with minimal adjustment to the Controller. However,
                insofar as all XML DBMSs rely to some extent on custom functions in custom namespaces<footnote>
                    <para>See <link>https://exist-db.org/exist/apps/fundocs/browse.html</link> for
                        eXist-db modules, <link>http://docs.basex.org/wiki/Module_Library</link> for
                        BaseX modules, and <link>https://docs.marklogic.com/all</link> for Marklogic
                        modules.</para>
                </footnote>, it is unlikely that a useful application of any complexity will be able
                to avoid proprietary features entirely. It is nonetheless the case that an
                application that does not rely on application-specific features at the Controller
                level reduces—even if it does not entirely eliminate—the extent of the lock-in to a
                specific XML DBMS product. The use of Free Software products, such as eXist-db and
                BaseX, reduces it further. For certain types of application, a second advantage may
                to limit the need for dynamic (and therefore slower) querying of the database in the
                construction of most views. Relatively static outputs can be cached in the middle
                layer and only regenerated when the sources are changed, and dynamic querying
                restricted to operations like searching. This kind of strategy can pay great
                dividends in application performance—at the cost of having to manage a cache.</para>
            <para>The principal disadvantage of using eXist-db only as a DBMS and locating all of
                the Controller logic in the PHP is an increase in the complexity of the overall
                architecture. Specifically, in this arrangement the Controller interjects a PHP
                layer between the View and the core XML DBMS services provided by XQuery within the
                Model, and the need to communicate between PHP and XQuery introduces an additional
                potential zone of failure. The separation of concerns (Controller in PHP, which
                interacts with a Model that understands XQuery) is generally (and not unreasonably)
                considered a virtue because of its modularity, since the connectivity between the
                two is mediated through an API. For example, PHP that knows how to communicate
                between a web form and a relational DBMS can be reused to communicate between the
                same form and an XML DBMS by adapting only the API-specific parts (for example, by
                replacing SQL queries with XQuery ones). But this modularity comes at the price of
                lengthening and complicating the distance between the View and the Model. For
                example, when a query fails during development under this approach, the failure may
                reside in the PHP code, in the XQuery code, or in a miscommunication (REST
                connectivity, API, or other). The PHP layer also complicates deployment because it
                requires configuration of both eXist-db and PHP resources on the host. With that
                said, this is an old and very widespread architecture in the relational DBMS world,
                as in the familiar LAMP architecture.</para>
            <para>We have applied several varieties of this implementation in production. The most
                manageable (easiest to develop, debug, maintain) arrangement has involved the
                following workflow:<orderedlist>
                    <listitem>
                        <para>The user enters information into an HTML form and submits the form,
                            which fires a PHP script.</para>
                    </listitem>
                    <listitem>
                        <para>The script collects the input, sanitizes and validates it, and
                            executes a REST call to an XQuery script that has been installed inside
                            eXist-db. This avoids the legibility challenges that arise when trying
                            to construct an XQuery script while observing PHP syntax. A sample query
                            as formulated within a PHP script might look like the following, where
                                <code>REST_PATH</code> has been declared with a value like
                                <code>http://example.com:8080/exist/rest</code> in an imported file,
                            and the <code>$country</code> and <code>$text</code> variables are
                            user-supplied values retrieved from the web form, after validation and
                            sanitation:<programlisting>$xql = REST_PATH . "/db/repertorium/xquery/runSearch.xql?country=$country&amp;text=$text";
echo file_get_contents($xql);</programlisting></para>
                    </listitem>
                    <listitem>
                        <para>eXist-db receives the REST call, dereferences the parameters with
                                <code>request:get-parameter()</code>, runs the query (previously
                            stored inside eXist-db), transforms the results to a well-balanced XHTML
                            fragment using <code>typeswitch()</code> or XSLT with
                                <code>transform:transform()</code>, and returns it to the PHP
                            script.</para>
                    </listitem>
                    <listitem>
                        <para>The PHP script inserts the returned result in the correct place, the
                            location of the <code>echo file_get_contents($xql);</code> instruction
                            in the example above.</para>
                    </listitem>
                    <listitem>
                        <para>The result is a valid XHTML page, which the PHP script then returns to
                            the user.</para>
                    </listitem>
                </orderedlist></para>
        </section>
        <section>
            <title><quote>XQuery, the server language</quote></title>
            <para>The previous section relegated eXist-db to the MySQL portion of the prototypical
                LAMP stack. However, it is also possible to build applications purely with XQuery.
                In this architecture, eXist-db functions as the entire AMP portion of the
                stack—handling the model, view, and controller (perhaps with a reverse proxy like
                Apache or Nginx in production scenarios for security purposes). The primary
                advantage of this model is that the developer need master only one core
                technology—XQuery—rather than many disparate ones. Kurt Cagle articulated this
                potential in an article published just months after XQuery achieved 1.0 status as a
                W3C Recommendation in 2017:<blockquote>
                    <para>Over the years, I’ve had the chance to program in a lot of different
                        server-side scripting languages--C, Perl, ASP, JSP, PHP, ASP.NET, Python,
                        Ruby, among others... As an XML developer, one of the problems that I come
                        across almost invariably within these languages is the fact that they are
                        shaped by people who view XML as something of an afterthought, a small
                        subset of the overall language that’s intended to satisfy those strange
                        people who think in angle brackets... A few recent XML databases have taken
                        XQuery to heart, and use it as the primary mechanism for accessing the XML
                        database content. One in particular, the open source eXist project, has gone
                        somewhat further, by inverting the normal sequence of working with XML where
                        the XML object or data store is passed in as an object to the XQuery filter
                        within the context of a server session. In the case of eXist, the various
                        session objects--request, response, server, and so forth--are instead
                        brought into the XQuery engine as externally defined XQuery methods. In
                        other words, in this situation, the server-side scripting language is not
                        PHP or ASP.NET or JSP, it's XQuery. [<xref linkend="cagle"/>]</para>
                </blockquote></para>
            <para>Cagle argues that XQuery need not be limited to querying and analyzing XML
                documents; it is fully capable as a server language for web applications. eXist-db’s
                Request, Response, and Session extension modules give developers the ability to
                access HTTP request parameters (as well as host names, server ports, etc.), control
                session parameters, and return HTTP responses with customized status, headers, body.
                An eXist-db application can even serve customized URL endpoints via its native URL
                Rewriting facility or through its support for RESTXQ.</para>
            <para>To illustrate the appeal of such an architecture, consider the syllabus of a
                half-day long seminar taught by one of this paper's authors at digital humanities
                institutes to students who had completed the Text Encoding Initiative track. In this
                short span of time, the instructor leveraged the participants' newly acquired
                knowledge of TEI XML to teach them enough XQuery to create a simple, dynamic,
                database driven web-based application. The purpose of the application was to let
                users browse through 20 TEI-encoded issues of Punch, a satirical, Victorian-era
                magazine used throughout the institute as a sample dataset. Each issue has a title
                and a number of sections, many of which are accompanied by illustrations. The
                application would present the reader with a list of issues, then let the reader
                click on an issue to view the contents of the issue by transforming the source TEI
                into HTML.</para>
            <para>The approach to developing the application consists of 4 major stages, each
                designed to introduce a new set of techniques in application development or
                capabilities of eXist-db: <orderedlist>
                    <listitem>
                        <para>querying a collection of XML documents with XPath</para>
                    </listitem>
                    <listitem>
                        <para>sorting results with XQuery</para>
                    </listitem>
                    <listitem>
                        <para>producing and serializing HTML to a web browser</para>
                    </listitem>
                    <listitem>
                        <para>transforming TEI into HTML</para>
                    </listitem>
                    <listitem>
                        <para>passing data between requests using dynamically-generated URL
                            parameters</para>
                    </listitem>
                    <listitem>
                        <para>encapsulating commonly used code into functions</para>
                    </listitem>
                    <listitem>
                        <para>importing functions from library modules</para>
                    </listitem>
                    <listitem>
                        <para>implementing full text search</para>
                    </listitem>
                </orderedlist>In other words, acquiring these skills would empower students to
                create a customized application around their edition. </para>
            <para>In preparation for building the application, the students download and install
                eXist-db on their workstations and upload the sample collection of Punch issues to
                the database, using eXide, eXist-db's built-in integrated development environment
                for XQuery. </para>
            <para>In the first stage, students build up from simple XPath expressions to a
                bare-bones application that shows a list of issues and lets readers choose an issue
                to view. They begin by opening a new query window in eXide and creating an XPath
                expression to list the titles of each
                issue:<programlisting>collection('/db/apps/punch/data')/tei:TEI/tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title</programlisting></para>
            <para>Submitting this query in eXide yields a sequence of TEI <code>&lt;title></code>
                elements. Students then extend this core XPath expression, using an XQuery FLWOR
                expression to iterate over the sequence and return a new sequence of HTML
                    <code>&lt;li></code> elements, an enclosed expression to obtain the string value
                of the title, and an "Order by" clause to sort the sequence
                alphabetically:<programlisting>for $issue in collection('/db/apps/punch/data')/tei:TEI
let $title := $issue/tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title
order by $title
return 
    &lt;li>{ $title/string() }&lt;/li>
</programlisting></para>
            <para>Next, students wrap this FLWOR expression inside an HTML <code>&lt;ol></code>
                element to produce an ordered list. With a query that produces valid HTML output,
                students save the query to the database, inside the <code>v1</code> subcollection
                for modules for the first version of the application:
                <code>v1/list-issues.xq</code>. </para>
            <para>Students then leave eXide to see how their query looks in a web browser. They
                opening up a new browser window and navigating to the query's web URL:
                    <code>http://localhost:8080/exist/apps/punch/v1/list-issues.xq</code>. This URL
                is serviced by eXist's Jetty server, which is configured to execute queries stored
                within the <code>/db/apps</code> database collection via the
                    <code>/exist/apps</code> URL space. Students then learn how to apply an XQuery
                serialization declaration to their query, so that the browser displays the HTML
                result of the query as a web page rather than as raw XML. Finally, students add an
                HTML link to each title, pointing to a second stored query and including a URL
                parameter, called <code>issue</code>, containing the issue's unique identifier (the
                issue's file name). </para>
            <para>Students then create a second module, <code>v1/view-whole-issue.xq</code>, which
                uses eXist's <code>request:get-parameter()</code> function to retrieve the
                    <code>issue</code> URL parameter. The query uses this issue identifier to select
                the issue's TEI document from the database:
                <programlisting>let $issue := request:get-parameter("issue", "")
(: We take $issue, e.g. 1914-07-01.xml, and can reconstruct the path to this document in the 
 : database by concatenating the base path to all Punch data with the $issue parameter. :)
let $doc := doc(concat("/db/apps/punch/data/", $issue))
let $text := $doc//tei:text
(: snip :)</programlisting></para>
            <para>Then it passes the TEI document through a function that transforms the entire TEI
                node into HTML, and inserts the results into an HTML
                block:<programlisting>(: continued :)
let $title := $doc/tei:TEI/tei:teiHeader/tei:fileDesc/tei:titleStmt/tei:title/text()
return
    &lt;html xmlns="http://www.w3.org/1999/xhtml">
        &lt;head>
            &lt;title>{$title}&lt;/title>
        &lt;/head>
        &lt;body>
            &lt;div>
                &lt;h1>{$title}&lt;/h1>
                {
                (: The tei-to-html:render() function takes 2 arguments: 
                 : 1. The TEI we want to display
                 : 2. An optional set of parameters.  In this case, we provide the 
                 :    "relative-image-path" for all TEI graphic elements; and we use
                 :    "show-page-breaks" to specify that TEI pb elements should be shown.
                 :)
                tei-to-html:render($text, 
                    &lt;parameters xmlns="">
                        &lt;param name="relative-image-path" value="/exist/apps/punch/data/"/>
                        &lt;param name="show-page-breaks" value="true"/>
                    &lt;/parameters>)
                }
            &lt;/div>
        &lt;/body>
    &lt;/html></programlisting></para>
            <para>This function for transforming TEI into HTML is located in an XQuery library
                module supplied to the students, <code>modules/tei-to-html.xqm</code>, which we
                import in the prolog of the <code>view-whole-issue.xq</code>
                query:<programlisting>import module namespace tei-to-html = "http://history.state.gov/ns/tei-to-html" at "../modules/tei-to-html.xqm";</programlisting></para>
            <para>The TEI-to-HTML module's primary function, <code>tei-to-html:render()</code>,
                recursively walks through the entire TEI document, using the XQuery Typeswitch
                expression to look at each node of the TEI document and pass the node off to the
                appropriate function:
                <programlisting>(: Typeswitch routine: Takes any node in a TEI content and either dispatches it to a dedicated 
 : function that handles that content (e.g. div), ignores it by passing it to the recurse() function
 : (e.g. text), or handles it directly (e.g. lb). :)
declare function tei-to-html:dispatch($node as node()*, $options) as item()* {
    typeswitch($node)
        case text() return $node
        case element(tei:TEI) return tei-to-html:recurse($node, $options)
        case element(tei:text) return tei-to-html:recurse($node, $options)
        case element(tei:front) return tei-to-html:recurse($node, $options)
        case element(tei:body) return tei-to-html:recurse($node, $options)
        case element(tei:back) return tei-to-html:recurse($node, $options)
        case element(tei:div) return tei-to-html:div($node, $options)
        case element(tei:head) return tei-to-html:head($node, $options)
        case element(tei:p) return tei-to-html:p($node, $options)
        case element(tei:hi) return tei-to-html:hi($node, $options)
        case element(tei:list) return tei-to-html:list($node, $options)
        case element(tei:item) return tei-to-html:item($node, $options)
        case element(tei:label) return tei-to-html:label($node, $options)
        case element(tei:ref) return tei-to-html:ref($node, $options)
        case element(tei:said) return tei-to-html:said($node, $options)
        case element(tei:lb) return &lt;br/>
        case element(tei:figure) return tei-to-html:figure($node, $options)
        case element(tei:graphic) return tei-to-html:graphic($node, $options)
        case element(tei:table) return tei-to-html:table($node, $options)
        case element(tei:row) return tei-to-html:row($node, $options)
        case element(tei:cell) return tei-to-html:cell($node, $options)
        case element(tei:pb) return tei-to-html:pb($node, $options)
        case element(tei:lg) return tei-to-html:lg($node, $options)
        case element(tei:l) return tei-to-html:l($node, $options)
        case element(tei:name) return tei-to-html:name($node, $options)
        case element(tei:milestone) return tei-to-html:milestone($node, $options)
        case element(tei:quote) return tei-to-html:quote($node, $options)
        case element(tei:said) return tei-to-html:said($node, $options)
        default return tei-to-html:recurse($node, $options)
};</programlisting></para>
            <para>For example, when the Typeswitch expression encounters a TEI <code>&lt;hi></code>
                element, it calls the <code>tei-to-html:hi()</code>
                function:<programlisting>declare function tei-to-html:hi($node as element(tei:hi), $options) as element()* {
    let $rend := $node/@rend
    return
        if ($rend eq "it") then
            &lt;em>{ tei-to-html:recurse($node, $options) }&lt;/em>
        else if ($rend eq "sc") then
            &lt;span style="font-variant: small-caps;">{ tei-to-html:recurse($node, $options) }&lt;/span>
        else 
            &lt;span class="hi">{ tei-to-html:recurse($node, $options) }&lt;/span>
};</programlisting></para>
            <para>While this transformation module is provided to the students (given time
                limitations), the students do have time to experiment by adding CSS values to the
                output. This exercise demonstrates that students can easily customize and extend the
                HTML transformation for around the needs of their edition.</para>
            <para>While readers familiar with XSLT may object to this method of transforming XML
                ("use XQuery to query, use XSLT to transform!"), this is a perfectly valid and has
                the advantage of allowing students to focus their limited time on mastering XQuery.
                It is certainly a better alternative to forcing them to learn another language
                before being able to transform their data. That would certainly not be possible in
                the space of a 3-hour seminar. For users who have mastered XSLT or are interested in
                learning it, though, eXist-db has a module for performing XSLT transformations,
                which under the hood passes the node and stylesheet to Saxon. But this recursive
                Typeswitch method does empower students to perform transformations in the same,
                unified "server" language—XQuery—as the rest of their application. </para>
            <para>The first version application works, but students quickly realize that it doesn't
                make much sense to display an entire issue on one web page. Thus, in the second
                version of the application, students replace the <code>view-whole-issue.xq</code>
                query with a table of contents: <code>view-issue-toc.xq</code>. This query uses a
                simple XPath <code>//tei:div</code> expression to retrieve all TEI
                    <code>&lt;div></code> elements and build a link using their child
                    <code>&lt;head></code> element as the title of the section and its
                    <code>@xml:id</code> attributes as the section's unique identifier for the link
                to a third query, <code>view-section.xq</code>. This query retrieves two URL
                parameters: issue identifier and section identifier. With this information, we can
                select the section's
                node:<programlisting>let $issue := request:get-parameter("issue", "")
let $section := request:get-parameter("section", "")
let $doc := doc(concat("/db/apps/punch/data/", $issue))
let $text := $doc/id($section)</programlisting></para>
            <para>Having selected the section, we pass this to the <code>tei-to-html:render()</code>
                function. </para>
            <para>This completes the second version of the application. The table of contents view
                is a major enhancement, but it is lacking: it displays the sections as a flat list,
                rather than a nested list. Also, it doesn't give any sense of the length of a
                section, which might range from a paragraph to many pages. Also, in the case of
                sections without titles, it simply displays, "(No title)". </para>
            <para>Thus, in the third version of the application, we focus on enhancing the table of
                contents view. We copy the contents of the <code>v2</code> subcollection into a new
                    <code>v3</code> subcollection, and extend <code>view-issue-toc.xq</code> with a
                trio of related functions: <code>generate-toc-from-divs()</code>, which creates a
                new HTML ordered list and passes child divs to <code>toc-div()</code>, which handles
                the text of the section, calls the <code>get-pages-from-div()</code> function to
                dynamically generate a page range (which could be useful for citations or inferring
                the length of a section), and then recursively passes any child sections back
                through the <code>generate-toc-from-divs()</code> function. This exercise
                demonstrates that students can easily customize their table of contents around the
                needs of their edition.</para>
            <para>In the final version of the application, we refactor the code base by moving
                repeated code into a library module—creating a <code>style:assemble-page()</code>
                function, to which we send each page's title and content and which applies a common
                layout to our HTML page—and adding an application-wide search box, served by a
                    <code>search.xq</code> query that presents the results and supported by an
                eXist-db full text index.</para>
            <para>The final step is to add a few files needed to distribute our application as an
                EXPath Package. The final project is available in the GitHub repository, <link
                    xlink:href="https://github.com/joewiz/punch"
                    xmlns:xlink="http://www.w3.org/1999/xlink"/>.</para>
            <para>The result is a fairly polished application that is highly customized around the
                needs of our edition. The application demonstrates all of the core techniques needed
                to build an edition: a collection view listing all "issues", a table of contents
                view of each "issue", and an item-level view of each "section"; the use of URL
                parameters to pass identifiers needed to locate items in the database; the use of
                XQuery to transform whole TEI documents or portions thereof into HTML; the use of
                functions and library modules to encapsulate code and facilitate its reuse; the use
                of the EXPath Package specification to facilitate distribution and sharing of code;
                and the use of eXist-db's full text index facility.</para>
            <para>Students were not expected to master all of these techniques in the course of the
                seminar. Rather, the purpose was to expose students to the iterative approach to
                hand-crafting one's own edition using pure XQuery, as implemented by eXist-db, and
                limited dependencies on external libraries: XQuery for querying data, transforming
                it, and publishing it via web technologies. </para>
            <para>While the approach is feasible for individuals, the primary weakness of this
                approach is that a hand-crafted application, in which all HTML is generated directly
                by XQuery script, may lead larger projects with a division of labor between multiple
                people (e.g., the visual designer or text encoding specialist) to depend too heavily
                on the XQuery programmer or face a steep learning curve. A visual designer would
                need to learn XQuery to alter the HTML structures generated by the XQuery. Likewise,
                an editor whose focus is the TEI encoding itself would need to learn XQuery to
                understand and adjust how the TEI is transformed into HTML. In addition, new
                XQuery-based TEI-to-anything transformation  library modules need to be written for
                each output format (e.g., PDF, ebook). </para>
            <para>The following two sections describe approaches developed in response to these
                limitations of the "pure XQuery" approach.</para>
        </section>
        <section>
            <title>Apps with HTML templating</title>
            <para>Like most CMS products, eXist-db has a templating functionality, one that is
                powerful and completely transparent in view components, and that supports
                annotations. The eXist-db templating functionality uses standard HTML5
                    <code>@data-*</code> attributes, e.g. <code>@data-template</code> for the
                template and <code>@data-template-*</code> for optional parameters, and that
                functionality can be extended with user-specified namespaced templating functions,
                e.g.:
                <programlisting>&lt;div data-template="core:peanut-butter" data-template-coating="chocolate"/&gt;</programlisting>
                Even if not using HTML5, the HTML <code>@class</code> attribute can be used for
                template names and static parameters, e.g.:
                <programlisting>&lt;div class="core:peanut-butter?coating=chocolate" /&gt;</programlisting></para>
            <para>Within templating, the current element is available the
                    <code>%templates:wrap</code> annotation, and nested template calls have access
                to application data through the <code>$model</code> variable. Manual processing
                control is achieved by calling <code>templates:process</code>.</para>
            <para>The templating module can be referenced in the XQuery code:
                <programlisting>import module namespace templates="http://exist-db.org/xquery/templates";</programlisting>
                Within the controller, the user can activate suitable templating processing, which
                is not necessary if you just use the built-in templating functions.</para>
            <para>Of the built-in functions, <code>templates:surround</code> is probably the most
                powerful one; it can be used with:
                <programlisting>templates:surround?with=templates/page.html&amp;at=produce</programlisting>
                to insert the content into the <code>with</code> template at the element with
                    <code>ID</code> produce. </para>
            <para>Thanks to the power of nested template calls, a major benefit of an HTML
                templating approach in eXist-db is the ability produce both mock-ups and production
                view components with more advanced search forms and result pages without turning to
                other solutions. The principal cost of HTML templating is the need to translate the
                templates to another template language. The initial domain knowledge and modeling
                remains intact and reusable.</para>
        </section>
        <section>
            <title>TEI Publisher</title>
            <para>TEI Publisher consists of two parts: a core library, which implements the TEI
                Processing Model (PM), and a development environment for customized web applications
                with built-in facilities for navigation, pagination, search, facsimile display,
                faceted browsing, etc. PM is a TEI-native vocabulary for expressing how XML
                documents should be transformed and rendered into various output formats (HTML,
                EPUB, PDF, etc.). PM lets users map TEI structures onto a dozen or so fundamental
                processing "behaviors" (e.g., treat <code>&lt;p></code> elements as "block",
                    <code>&lt;hi></code> elements as "inline", <code>&lt;list></code> and
                    <code>&lt;item></code> elements as components of "list" structures, etc.), and
                TEI Publisher ships with sane defaults for ensuring, for example, that PM's
                CSS-centric style language is faithfully conveyed to the various output formats. TEI
                Publisher also supports overriding these defaults with custom, output
                format-specific affordances (such as LaTeX boilerplate or XSL-FO font definitions).
                It supports extension points to XQuery functions for cases where PM alone cannot
                accomplish the desired results. TEI Publisher even leverages PM's theoretical
                support for documents encoded in non-TEI vocabularies, and ships with support for
                DocBook-encoded documents. The most recent major release, 4.0, was redesigned to use
                Web Components in its views, allowing users to freely add, remove, and combine
                panels containing different views, such as facsimile, translations, and maps.<footnote>
                    <para>This functionality could be achieved with other View components, such as
                        by building reusuable components with React.js [<xref linkend="React.js"/>],
                        which brings it closer to web apps, as described in the preceding
                        section.</para>
                </footnote>The large number of already available web components makes most
                adaptations possible with just some foundational HTML knowledge, but users with
                advanced requirements can implement additional components on the basis of modeling
                experience and knowledge of the HTML5 specification, and specifically of containing
                web components. Most users, however, are likely to find that TEI Publisher provides
                ways to embed texts into an application context, supporting the integration of
                navigation, pagination, search, facsimile display, and more.</para>
            <para>The principal costs of TEI Publisher, as with other web publishing frameworks, are
                twofold. The first cost lies in the start-up, that is, in the time and resource
                requirements to perform a technology switch. The second cost, also shared with any
                web publishing framework, involves the potential for lock-in, since building a site
                within a particular framework implicitly discourages migration to a different
                framework at a later date. TEI Publisher cannot eliminate these costs, but it
                mitigates both by using Free Software and open formats, and by following both actual
                (such as HTML5) and de facto (such as TEI) standards, it reduces both the start-up
                cost and the cost of potential future migration.</para>
        </section>
    </section>
    <section>
        <title>Conclusion</title>
        <section>
            <title>General</title>
            <para>Preview of summary conclusions: technical (essentially para-technical, involving
                sustainability) and philosophical</para>
        </section>
        <section>
            <title>Sustainability</title>
            <para>CMS supports easy customization within anticipated, supported parameters, while
                major innovation may be harder than building from scratch</para>
            <para>CMS supports <emphasis role="ital">.xar</emphasis> packaging for easy replication,
                distribution, deployment; porting PHP + eXist-db is much more complicated</para>
            <para>CMS increases lock-in and complicates migration to different XML database, however
                major work with data structures and modeling is still reusable</para>
        </section>
        <section>
            <title>The interface and the scholarship</title>
            <para>Contrast <quote>CMS lets you concentrate on the content and leave the technology
                    to the tech professionals</quote> with <quote>the interface is part of the
                    scholarship</quote> (cite Graz 2016 DiXiT presentations by Wout and Tara and
                Joris)</para>
        </section>
    </section>
    <bibliography>
        <title>Works cited</title>
        <bibliomixed xml:id="apache" xreflabel="Apache"><quote>Apache HTTP server project.</quote>
            <link>https://httpd.apache.org</link></bibliomixed>
        <bibliomixed xml:id="basex" xreflabel="BaseX">BaseX. The XML framework.
                <link>http://basex.org</link>/</bibliomixed>
        <bibliomixed xml:id="cagle" xreflabel="Cagle 2007">Cagle, Kurt. <quote>XQuery, the server
                language.</quote> 2007-06-06. <link
                xlink:href="https://www.xml.com/pub/a/2007/06/01/xquery-the-server-language.html"
                xmlns:xlink="http://www.w3.org/1999/xlink"/></bibliomixed>
        <bibliomixed xml:id="eXist-db" xreflabel="eXist-db"><quote>eXist-db.</quote>
            <link>https://exist-db.org</link></bibliomixed>
        <bibliomixed xml:id="templating" xreflabel="eXist-db HTML templating"><quote>eXist-db: HTML
                Templating Module.</quote>
            <link>https://exist-db.org/exist/apps/doc/templating.xml</link></bibliomixed>
        <bibliomixed xml:id="webapp" xreflabel="eXist-db Web application"><quote>eXist-db: Getting
                started with Web application development.</quote>
            <link>https://exist-db.org/exist/apps/doc/development-starter</link></bibliomixed>
        <bibliomixed xml:id="Jetty" xreflabel="Jetty">Eclipse Jetty.
                <link>https://www.eclipse.org/jetty/</link></bibliomixed>
        <bibliomixed xml:id="marklogic" xreflabel="Marklogic">MarkLogic | Data Integration and NoSQL
            Databases for Your Business. <link>https://www.marklogic.com/</link></bibliomixed>
        <bibliomixed xml:id="mvc" xreflabel="MVC architecture">Wideskills. <quote>Introduction to
                MVC architecture.</quote>
            <link>https://www.wideskills.com/struts/introduction-to-mvc-architecture</link></bibliomixed>
        <bibliomixed xml:id="php" xreflabel="PHP"><quote>PHP: hypertext preprocessor.</quote>
            <link>https://www.php.net/</link></bibliomixed>
        <bibliomixed xml:id="punch" xreflabel="Punch">Wicentowski, Joe. <quote>Punch. A simple
                application written in XQuery for eXist demonstrating how to create a dynamic,
                searchable website for TEI text.</quote>
            <link>https://github.com/joewiz/punch</link></bibliomixed>
        <bibliomixed xml:id="reenskaug" xreflabel="Reenskaug">Reenskaug, Trygve M. H. <quote>MVC.
                Xerox PARC 1978–79.</quote>
            <link>http://heim.ifi.uio.no/~trygver/themes/mvc/mvc-index.html</link></bibliomixed>
        <bibliomixed xreflabel="React" xml:id="React.js">React. A JavaScript library for building
            user interfaces. <link>https://reactjs.org/</link></bibliomixed>
        <bibliomixed xml:id="reeses" xreflabel="Reese’s"><quote>Vintage 80s Reese’s peanut butter
                cups commercial with walkers.</quote>
            <link>https://www.youtube.com/watch?v=DJLDF6qZUX0</link></bibliomixed>
        <bibliomixed xml:id="exist-book" xreflabel="Siegel and Retter 2014">Siegel, Erik and Adam
            Retter. <emphasis role="ital">eXist. A NoSQL document database and application
                platform.</emphasis> Sebastopol, CA: O’Reilly. 2014.</bibliomixed>
        <bibliomixed xml:id="teiPublisher" xreflabel="TEI Publisher"><quote>TEI publisher.</quote>
            <link>https://teipublisher.com</link></bibliomixed>
        <bibliomixed xml:id="teiPublisher4.0" xreflabel="TEI Publisher 4.0"><quote>TEI Publisher
                4.0.</quote> Product announcement. 2018-12-20.
                <link>https://teipublisher.com/exist/apps/tei-publisher/doc/blog/tei-publisher-40.xml</link></bibliomixed>
        <bibliomixed xml:id="teiPublisherQuick" xreflabel="TEI Publisher Quickstart"><quote>TEI
                Publisher Quickstart.</quote>
            <link>https://teipublisher.com/exist/apps/tei-publisher/doc/documentation.xml</link></bibliomixed>
        <bibliomixed xml:id="upton" xreflabel="Upton 2013">Upton, Emily. <quote>The fascinating rise
                of Reese’s Peanut Butter Cups.</quote>
            <emphasis role="ital">Business insider.</emphasis> June 30, 2013.
                <link>https://www.businessinsider.com/the-fascinating-rise-of-reeses-peanut-butter-cups-2013-6</link></bibliomixed>
        <bibliomixed xml:id="webComponents" xreflabel="Web Components">webcomponents.org.
                <quote>Introduction.</quote>
            <link>https://www.webcomponents.org/introduction</link></bibliomixed>
    </bibliography>
</article>
